#!/usr/bin/perl

# Daniel "Trizen" Șuteu
# Date: 09 December 2025
# https://github.com/trizen

# kth_root_mod: find all x (0 <= x < m) with x^k ≡ a (mod m)

use 5.036;
use ntheory qw(:all);
use Test::More tests => 9;

# Branching Hensel: lift root(s) r modulo p to roots modulo p^e for x^k ≡ a (mod p^e)
# Returns list of lifted roots modulo p^e. Handles derivative==0 by branching on possible lifts.
sub hensel_lift_multi {
    my ($r, $k, $A, $p, $e) = @_;
    my @current = ($r % $p);
    my $t       = 1;
    my $mod     = $p;
    while ($t < $e) {
        my $M = $mod * $p;
        my @next;
        foreach my $x (@current) {

            # f(x) = x^k - A  modulo M
            my $fx = (powmod($x, $k, $M) - ($A % $M)) % $M;
            $fx += $M if $fx < 0;

            # derivative modulo p
            my $der     = ($k * powmod($x, $k - 1, $p)) % $p;
            my $inv_der = invmod($der, $p);
            if (defined $inv_der) {

                # unique Newton lift
                my $q = divint($fx, $mod);
                my $u = ((-$q) * $inv_der) % $p;
                $u += $p if $u < 0;
                my $xnew = ($x + $u * $mod) % $M;
                push @next, $xnew;
            }
            else {
                # derivative 0 mod p: try all candidates u in 0..p-1
                # keep only those that satisfy the congruence modulo M
                my $a_mod_M = $A % $M;
                for my $u (0 .. $p - 1) {
                    my $cand = ($x + $u * $mod) % $M;
                    if (powmod($cand, $k, $M) == $a_mod_M) {
                        push @next, $cand;
                    }
                }
            }
        }

        # deduplicate
        my %seen;
        @current = grep { !$seen{$_}++ } @next;
        return () unless @current;    # if no lifts at some stage, no solution
        $t++;
        $mod *= $p;
    }

    my $pp = powint($p, $e);
    return map { $_ % $pp } @current;
}

# Solve x^k ≡ a (mod p) for prime p (returns list of roots mod p)
sub roots_mod_prime {
    my ($k, $v, $p) = @_;
    $v %= $p;
    if ($p == 2) {
        my @out;
        for my $x (0 .. 1) {
            push @out, $x if powmod($x, $k, 2) == $v;
        }
        return @out;
    }
    return (0) if $v == 0;

    # use znprimroot for primitive root
    my $g = znprimroot($p);
    die "no primitive root mod $p?" unless defined $g;

    # discrete log of v to base g using znlog
    my $A = znlog($v, $g, $p);
    return () unless defined $A;

    my $mod = $p - 1;
    my $d   = gcd($k, $mod);
    return () if ($A % $d) != 0;

    my $km     = divint($k,   $d);
    my $Am     = divint($A,   $d);
    my $mm     = divint($mod, $d);
    my $inv_km = invmod($km, $mm);
    die "no inverse (unexpected)" unless defined $inv_km;
    my $y0 = mulmod($Am, $inv_km, $mm);
    my @ys;
    for my $t (0 .. $d - 1) {
        push @ys, muladdmod($t, $mm, $y0, $mod);
    }
    my %seen;
    my @roots = grep { !$seen{$_}++ } map { powmod($g, $_, $p) } @ys;
    return @roots;
}

# Solve x^k ≡ a (mod p^e) for prime power
sub roots_mod_primepower {
    my ($k, $A, $p, $e) = @_;
    my $pe = $p**$e;
    $A %= $pe;

    # small p^e brute force (kept modest)
    if ($pe <= 50000) {
        my @sol;
        for my $x (0 .. $pe - 1) {
            push @sol, $x if powmod($x, $k, $pe) == $A;
        }
        return @sol;
    }

    # valuation of a
    my $va = valuation($A, $p);

    if ($va > 0) {

        # For x = p^{vx} * u with gcd(u,p)=1, we need k*vx = va
        return () if ($va % $k) != 0;
        my $vx    = divint($va, $k);
        my $new_e = $e - $k * $vx;
        if ($new_e <= 0) {

            # any x with valuation >= vx will satisfy modulo p^e
            my @sol;
            my $count = $p**($e - $vx);
            for my $t (0 .. $count - 1) {
                push @sol, ($t * ($p**$vx)) % $pe;
            }
            my %seen;
            @sol = grep { !$seen{$_}++ } @sol;
            return @sol;
        }
        else {
            my $a2      = divint($A, ($p**($k * $vx))) % ($p**$new_e);
            my @u_roots = roots_mod_primepower($k, $a2, $p, $new_e);
            my %seen;
            my @sol = grep { !$seen{$_}++ } map { ($_ * ($p**$vx)) % $pe } @u_roots;
            return @sol;
        }
    }

    # gcd(a,p)=1: find roots mod p then Hensel lift each (branching when needed)
    my @r0 = roots_mod_prime($k, $A, $p);
    return () unless @r0;
    my %seen;
    my @all;
    foreach my $r (@r0) {
        my @lifts = hensel_lift_multi($r, $k, $A, $p, $e);
        push @all, @lifts if @lifts;
    }
    @all = grep { defined $_ } @all;
    @all = map  { $_ % $pe } @all;
    @all = grep { !$seen{$_}++ } @all;
    return @all;
}

# Main: combine prime-power solutions and return all roots modulo m
sub kth_root_mod {
    my ($k, $v, $m) = @_;
    die "m must be >= 1" if $m < 1;
    $v %= $m;

    # factor m into prime factors (with multiplicity)
    my @pf = factor($m);
    my %exp;
    $exp{$_}++ for @pf;

    # collect solutions for each prime power
    my @moduli;
    my @solutions_lists;
    for my $p (sort { $a <=> $b } keys %exp) {
        my $e   = $exp{$p};
        my $pe  = $p**$e;
        my @sol = roots_mod_primepower($k, $v, $p, $e);
        return () unless @sol;
        push @moduli,          $pe;
        push @solutions_lists, \@sol;
    }

    # combine with CRT (cartesian product)
    my @results  = (0);
    my @res_mods = (1);

    for my $idx (0 .. $#moduli) {
        my $mod_i  = $moduli[$idx];
        my $solref = $solutions_lists[$idx];
        my @new_results;
        my @new_mods;
        for my $j (0 .. $#results) {
            my $r  = $results[$j];
            my $rn = $res_mods[$j];
            foreach my $s (@$solref) {
                my $crt_mod = lcm($rn, $mod_i);
                my $crt_val = chinese([$r, $rn], [$s, $mod_i]);
                next unless defined $crt_val;
                push @new_results, $crt_val % $crt_mod;
                push @new_mods,    $crt_mod;
            }
        }

        # deduplicate (value@mod)
        my %seen;
        my (@uniq_vals, @uniq_mods);
        for my $i (0 .. $#new_results) {
            my $v   = $new_results[$i] % $new_mods[$i];
            my $key = "$v\@" . $new_mods[$i];
            next if $seen{$key}++;
            push @uniq_vals, $v;
            push @uniq_mods, $new_mods[$i];
        }
        @results  = @uniq_vals;
        @res_mods = @uniq_mods;
    }

    # normalize to 0..m-1 and unique
    my %seen;
    my @final = map { $_ % $m } @results;
    @final = grep { !$seen{$_}++ } @final;
    @final = sort { $a <=> $b } @final;
    return @final;
}

is_deeply([kth_root_mod(3, 2, 101)], [26]);
is_deeply([kth_root_mod(2, 0, 16)],  [0, 4, 8, 12]);
is_deeply([kth_root_mod(2, 1, 101)], [1, 100]);
is_deeply([kth_root_mod(5, 4320, 5040)],
          [120, 330, 540, 750, 960, 1170, 1380, 1590, 1800, 2010, 2220, 2430, 2640, 2850, 3060, 3270, 3480, 3690, 3900, 4110, 4320, 4530, 4740, 4950]);
is_deeply(
          [kth_root_mod(6, 4320, 5040)],
          [30,   60,   90,   120,  150,  180,  240,  270,  300,  330,  360,  390,  450,  480,  510,  540,  570,  600,  660,  690,  720,  750,  780,  810,
           870,  900,  930,  960,  990,  1020, 1080, 1110, 1140, 1170, 1200, 1230, 1290, 1320, 1350, 1380, 1410, 1440, 1500, 1530, 1560, 1590, 1620, 1650,
           1710, 1740, 1770, 1800, 1830, 1860, 1920, 1950, 1980, 2010, 2040, 2070, 2130, 2160, 2190, 2220, 2250, 2280, 2340, 2370, 2400, 2430, 2460, 2490,
           2550, 2580, 2610, 2640, 2670, 2700, 2760, 2790, 2820, 2850, 2880, 2910, 2970, 3000, 3030, 3060, 3090, 3120, 3180, 3210, 3240, 3270, 3300, 3330,
           3390, 3420, 3450, 3480, 3510, 3540, 3600, 3630, 3660, 3690, 3720, 3750, 3810, 3840, 3870, 3900, 3930, 3960, 4020, 4050, 4080, 4110, 4140, 4170,
           4230, 4260, 4290, 4320, 4350, 4380, 4440, 4470, 4500, 4530, 4560, 4590, 4650, 4680, 4710, 4740, 4770, 4800, 4860, 4890, 4920, 4950, 4980, 5010
          ]
         );
is_deeply(
          [kth_root_mod(124, 2016, 5040)],
          [42,   84,   126,  168,  252,  294,  336,  378,  462,  504,  546,  588,  672,  714,  756,  798,  882,  924,  966,  1008, 1092, 1134, 1176, 1218,
           1302, 1344, 1386, 1428, 1512, 1554, 1596, 1638, 1722, 1764, 1806, 1848, 1932, 1974, 2016, 2058, 2142, 2184, 2226, 2268, 2352, 2394, 2436, 2478,
           2562, 2604, 2646, 2688, 2772, 2814, 2856, 2898, 2982, 3024, 3066, 3108, 3192, 3234, 3276, 3318, 3402, 3444, 3486, 3528, 3612, 3654, 3696, 3738,
           3822, 3864, 3906, 3948, 4032, 4074, 4116, 4158, 4242, 4284, 4326, 4368, 4452, 4494, 4536, 4578, 4662, 4704, 4746, 4788, 4872, 4914, 4956, 4998
          ]
         );
is_deeply([kth_root_mod(5, 43,  5040)], [1723]);
is_deeply([kth_root_mod(5, 243, 1000)], [3, 203, 403, 603, 803]);
is_deeply(
          [kth_root_mod(383, 32247425005, 64552988163)],
          [49,          168545710,   337091371,   505637032,   674182693,   842728354,   1011274015,  1179819676,  1348365337,  1516910998,
           1685456659,  1854002320,  2022547981,  2191093642,  2359639303,  2528184964,  2696730625,  2865276286,  3033821947,  3202367608,
           3370913269,  3539458930,  3708004591,  3876550252,  4045095913,  4213641574,  4382187235,  4550732896,  4719278557,  4887824218,
           5056369879,  5224915540,  5393461201,  5562006862,  5730552523,  5899098184,  6067643845,  6236189506,  6404735167,  6573280828,
           6741826489,  6910372150,  7078917811,  7247463472,  7416009133,  7584554794,  7753100455,  7921646116,  8090191777,  8258737438,
           8427283099,  8595828760,  8764374421,  8932920082,  9101465743,  9270011404,  9438557065,  9607102726,  9775648387,  9944194048,
           10112739709, 10281285370, 10449831031, 10618376692, 10786922353, 10955468014, 11124013675, 11292559336, 11461104997, 11629650658,
           11798196319, 11966741980, 12135287641, 12303833302, 12472378963, 12640924624, 12809470285, 12978015946, 13146561607, 13315107268,
           13483652929, 13652198590, 13820744251, 13989289912, 14157835573, 14326381234, 14494926895, 14663472556, 14832018217, 15000563878,
           15169109539, 15337655200, 15506200861, 15674746522, 15843292183, 16011837844, 16180383505, 16348929166, 16517474827, 16686020488,
           16854566149, 17023111810, 17191657471, 17360203132, 17528748793, 17697294454, 17865840115, 18034385776, 18202931437, 18371477098,
           18540022759, 18708568420, 18877114081, 19045659742, 19214205403, 19382751064, 19551296725, 19719842386, 19888388047, 20056933708,
           20225479369, 20394025030, 20562570691, 20731116352, 20899662013, 21068207674, 21236753335, 21405298996, 21573844657, 21742390318,
           21910935979, 22079481640, 22248027301, 22416572962, 22585118623, 22753664284, 22922209945, 23090755606, 23259301267, 23427846928,
           23596392589, 23764938250, 23933483911, 24102029572, 24270575233, 24439120894, 24607666555, 24776212216, 24944757877, 25113303538,
           25281849199, 25450394860, 25618940521, 25787486182, 25956031843, 26124577504, 26293123165, 26461668826, 26630214487, 26798760148,
           26967305809, 27135851470, 27304397131, 27472942792, 27641488453, 27810034114, 27978579775, 28147125436, 28315671097, 28484216758,
           28652762419, 28821308080, 28989853741, 29158399402, 29326945063, 29495490724, 29664036385, 29832582046, 30001127707, 30169673368,
           30338219029, 30506764690, 30675310351, 30843856012, 31012401673, 31180947334, 31349492995, 31518038656, 31686584317, 31855129978,
           32023675639, 32192221300, 32360766961, 32529312622, 32697858283, 32866403944, 33034949605, 33203495266, 33372040927, 33540586588,
           33709132249, 33877677910, 34046223571, 34214769232, 34383314893, 34551860554, 34720406215, 34888951876, 35057497537, 35226043198,
           35394588859, 35563134520, 35731680181, 35900225842, 36068771503, 36237317164, 36405862825, 36574408486, 36742954147, 36911499808,
           37080045469, 37248591130, 37417136791, 37585682452, 37754228113, 37922773774, 38091319435, 38259865096, 38428410757, 38596956418,
           38765502079, 38934047740, 39102593401, 39271139062, 39439684723, 39608230384, 39776776045, 39945321706, 40113867367, 40282413028,
           40450958689, 40619504350, 40788050011, 40956595672, 41125141333, 41293686994, 41462232655, 41630778316, 41799323977, 41967869638,
           42136415299, 42304960960, 42473506621, 42642052282, 42810597943, 42979143604, 43147689265, 43316234926, 43484780587, 43653326248,
           43821871909, 43990417570, 44158963231, 44327508892, 44496054553, 44664600214, 44833145875, 45001691536, 45170237197, 45338782858,
           45507328519, 45675874180, 45844419841, 46012965502, 46181511163, 46350056824, 46518602485, 46687148146, 46855693807, 47024239468,
           47192785129, 47361330790, 47529876451, 47698422112, 47866967773, 48035513434, 48204059095, 48372604756, 48541150417, 48709696078,
           48878241739, 49046787400, 49215333061, 49383878722, 49552424383, 49720970044, 49889515705, 50058061366, 50226607027, 50395152688,
           50563698349, 50732244010, 50900789671, 51069335332, 51237880993, 51406426654, 51574972315, 51743517976, 51912063637, 52080609298,
           52249154959, 52417700620, 52586246281, 52754791942, 52923337603, 53091883264, 53260428925, 53428974586, 53597520247, 53766065908,
           53934611569, 54103157230, 54271702891, 54440248552, 54608794213, 54777339874, 54945885535, 55114431196, 55282976857, 55451522518,
           55620068179, 55788613840, 55957159501, 56125705162, 56294250823, 56462796484, 56631342145, 56799887806, 56968433467, 57136979128,
           57305524789, 57474070450, 57642616111, 57811161772, 57979707433, 58148253094, 58316798755, 58485344416, 58653890077, 58822435738,
           58990981399, 59159527060, 59328072721, 59496618382, 59665164043, 59833709704, 60002255365, 60170801026, 60339346687, 60507892348,
           60676438009, 60844983670, 61013529331, 61182074992, 61350620653, 61519166314, 61687711975, 61856257636, 62024803297, 62193348958,
           62361894619, 62530440280, 62698985941, 62867531602, 63036077263, 63204622924, 63373168585, 63541714246, 63710259907, 63878805568,
           64047351229, 64215896890, 64384442551
          ]
         );

# ----- CLI usage -----
if (@ARGV == 3) {
    my ($k, $v, $m) = @ARGV;
    my @sol = kth_root_mod($k, $v, $m);
    if (!@sol) {
        print "No solution: x^$k ≡ $v (mod $m) has no solution.\n";
    }
    else {
        print scalar(@sol),                        " solution(s) mod $m:\n";
        print join(", ", sort { $a <=> $b } @sol), "\n";
    }
    exit 0;
}
